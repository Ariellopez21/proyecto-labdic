\section{Marco teórico}\label{sec:marco_teorico}

\subsection{PostgreSQL}

Para el desarrollo del sistema se opta por utilizar PostgreSQL como motor de base de datos relacional, debido a que ofrece un conjunto de características avanzadas que garantizan integridad, eficiencia y escalabilidad en entornos multiusuario~\cite{aws_mysql_postgresql}.

En primer lugar, PostgreSQL asegura el cumplimiento estricto de las propiedades ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad), lo que garantiza que las transacciones sean confiables incluso bajo condiciones de alta concurrencia o fallos inesperados
~\cite{devto_postgresql_acid}~\cite{airbyte_sqlite_postgresql}.
Esta solidez resulta fundamental para un sistema de préstamos e inventario, donde la pérdida o corrupción de datos comprometería el control de los recursos.

Adicionalmente, PostgreSQL proporciona un soporte amplio de tipos de datos más allá de los estándares SQL, incluyendo JSONB para almacenar y consultar datos semiestructurados, arrays, enumerados y UUID
~\cite{airbyte_sqlite_postgresql}~\cite{prisma_postgresql_benefits}.
Estas capacidades permiten modelar de manera más flexible los distintos elementos del inventario y facilitar futuras ampliaciones del sistema sin recurrir a soluciones externas.

Otro aspecto clave corresponde a la optimización de consultas mediante algoritmos de índices avanzados. PostgreSQL soporta estructuras como B-Tree, Hash, GiST, GIN y BRIN, lo que posibilita mejorar el rendimiento en búsquedas complejas, filtrados y operaciones sobre grandes volúmenes de datos~\cite{prisma_postgresql_benefits}. Esta versatilidad en el manejo de índices resulta especialmente ventajosa para mantener la eficiencia del sistema a medida que la cantidad de registros crezca.

Finalmente, la implementación de Multiversion Concurrency Control (MVCC) permite que múltiples transacciones de lectura y escritura se ejecuten de manera simultánea sin generar bloqueos innecesarios
~\cite{aws_mysql_postgresql}~\cite{airbyte_sqlite_postgresql}.
Este enfoque asegura que el sistema pueda atender a varios usuarios en paralelo, manteniendo la coherencia de los datos y mejorando la experiencia de uso.

\subsection{Python + SQLAlchemy}

La elección de Python y SQLAlchemy no constituye una novedad en el ámbito del desarrollo de aplicaciones, ya que existe una amplia cantidad de documentación, tutoriales y guías en línea que respaldan su uso
~\cite{4geeks_sqlalchemy_intro}~\cite{hostgator_orm}~\cite{auth0_sqlalchemy_tutorial}. Python destaca por su facilidad de aprendizaje y la abundancia de recursos didácticos, lo que facilita la adopción por parte de programadores junior en implementaciones básicas. Al mismo tiempo, su versatilidad y compatibilidad con programación asíncrona avanzada, combinada con frameworks modernos, lo convierten en una herramienta altamente productiva también para desarrolladores senior que requieren mayor control a bajo nivel y optimización en entornos de producción. Esta dualidad entre accesibilidad y potencia explica en gran medida su popularidad y la solidez de su ecosistema.
~\cite{learnpython_popularity}~\cite{anaconda_why_python}

En cuanto a la capa de acceso a datos, SQLAlchemy se adopta por su equilibrio entre expresividad y control. Aporta dos niveles de abstracción: En primer lugar, \textit{SQLAlchemy Core}, un generador de SQL declarativo y composable que permite optimización fina cuando es necesario, y el segundo consta del ORM (Object Relational Mapper), que modela el dominio en clases y relaciones, favoreciendo consistencia del modelo, reutilización y pruebas. Posee una amplia compatibilidad de dialectos entre ellos PostgreSQL, MySQL/MariaDB y SQLite~\cite{sqlalchemy_features}. Reduciendo el acoplamiento a un motor específico y facilitando portabilidad. Finalmente, la integración nativa con Alembic habilita un flujo de trabajo coherente para la evolución del esquema, con migraciones versionadas y reproducibles.

\subsection{Alembic}

En el proyecto se utiliza Python como lenguaje de programación para el backend y SQLAlchemy como ORM para la gestión de la persistencia de datos. Bajo este contexto, se ha decidido implementar Alembic como herramienta de migración de base de datos, dado que ofrece un conjunto de características que se ajustan de manera óptima a las necesidades del sistema.

En primer lugar, Alembic permite manejar de forma estructurada la evolución del esquema de la base de datos, lo que resulta esencial en proyectos donde el modelo de datos se encuentra en constante ajuste durante las fases de desarrollo ~\cite{pingcap_alembic}. Esta capacidad evita inconsistencias entre los entornos de prueba, desarrollo y producción.

Alembic facilita la generación y aplicación de migraciones de forma controlada, permitiendo registrar cada modificación en scripts versionados que conforman un historial claro de los cambios realizados en la base de datos~\cite{pingcap_alembic}~\cite{devto_alembic}. Esta trazabilidad garantiza la consistencia del modelo de datos a lo largo de todo el ciclo de vida del proyecto, agiliza el despliegue de actualizaciones y reduce el riesgo de errores humanos asociados a modificaciones manuales del esquema. Resulta especialmente valioso en entornos colaborativos, donde múltiples desarrolladores interactúan con la misma base de datos y es imprescindible mantener un control preciso de la evolución del esquema.

Finalmente, la compatibilidad nativa de Alembic con Python y SQLAlchemy refuerza su pertinencia en el proyecto ~\cite{pingcap_alembic}. Al integrarse de manera fluida con el stack tecnológico seleccionado, se optimiza la curva de aprendizaje y se garantiza la coherencia entre las distintas capas del sistema.

En conjunto, estas características hacen que Alembic se presente como la opción más adecuada para la gestión de versiones de la base de datos del proyecto, asegurando control, consistencia y escalabilidad en la administración del modelo de datos.

\subsection{Litestar}

Litestar se distingue por ofrecer un rendimiento superior, alcanzando aproximadamente el doble de velocidad que FastAPI. Esta ventaja proviene en gran medida de su uso de msgspec como motor de serialización, en lugar de Pydantic, lo que reduce significativamente la sobrecarga en el ciclo de solicitud y respuesta.
~\cite{betterstack_litestar_fastapi}~\cite{plainenglish_litestar_fastapi}

Para proyectos que utilizan SQLAlchemy como ORM, Litestar incorpora un plugin nativo que simplifica la gestión de sesiones y transacciones, junto con un Repository Patter integrado que facilita las operaciones de base de datos~\cite{litestar_advanced_alchemy}. También incluye una capa de servicio para organizar la lógica de negocio y la transformación de datos, cuenta con paginación y filtrado integrados, y ofrece herramientas CLI que facilitan las migraciones de base de datos.
~\cite{betterstack_litestar_fastapi}~\cite{litestar_advanced_alchemy}

Otro aspecto relevante es su sistema de inyección de dependencias, inspirado en pytest, que supera en flexibilidad al de FastAPI. Este permite declarar dependencias en distintos niveles de aplicación, router, controlador y handler, lo que brinda un control más granular sobre la arquitectura del proyecto.
~\cite{litestar_dependency_injection}~\cite{plainenglish_litestar_fastapi}

Finalmente, Litestar integra de forma nativa diversas funcionalidades que en otros frameworks requieren librerías externas. Entre ellas se incluyen autenticación JWT y sistemas personalizados de autenticación, soporte completo de CORS, manejo de sesiones con integración a SQLAlchemy, guards de autorización para control de acceso granular y un middleware robusto y extensible.
~\cite{betterstack_litestar_fastapi}~\cite{plainenglish_litestar_fastapi}~\cite{litestar_authentication}

\subsection{Vue3 + TypeScript}

Vue 3 es un framework frontend altamente flexible, que fue diseñado para el desarrollo de aplicaciones web modernas y escalables, facilita un código modular, rendimiento optimizado mediante mejoras en compilación y ejecución, y soporte nativo para TypeScript, además, trabaja muy bien con PrimeVue debido a la amplia colección de componentes preconstruidos que ofrece, los cuales aceleran la implementación de funcionalidades y aseguran una interfaz de usuario consistente y responsiva, en conjunto, permite generar código más robusto y detectar errores en etapas tempranas del desarrollo~\cite{immune_vue3}.

TypeScript es uno de los lenguaje recomendados y esenciales para el desarrollo frontend, pues, permite detectar errores en tiempo de compilación, reduciendo fallas que de otra forma solo aparecerían en ejecución, además, fomenta una mejor organización del código y soporta la programación orientada a objetos mediante clases e interfaces~\cite{acrocommerce_ts}.
Esto aporta claridad, documentación implícita y una mantenimiento mejorado, aunque su uso implica una curva de aprendizaje inicial, los beneficios en calidad y escalabilidad superan ampliamente dichas limitaciones~\cite{strapi_ts}.

\subsection{PrimeVue + Vite + Pinia + TailwindCSS}

PrimeVue se ha consolidado como una de las bibliotecas de componentes más robustas y completas para aplicaciones desarrolladas con Vue.js. Con más de 80 componentes disponibles, abarca desde elementos básicos hasta recursos avanzados como \texttt{DataTables}, \texttt{TreeTables} y gráficos interactivos, lo que la convierte en una solución integral para proyectos de diversa complejidad.~\cite{primevue_intro}

Un aspecto relevante es que PrimeVue adopta un esquema de versionado semántico, lo que garantiza estabilidad y continuidad a largo plazo, evitando cambios disruptivos que puedan comprometer sistemas en producción.~\cite{mobilereality_vue_libs}

Otro de sus puntos fuertes es la flexibilidad en el diseño, ya que ofrece soporte tanto para el modo \texttt{styled} como \texttt{unstyled}, permitiendo integrarse de manera óptima con frameworks de estilos modernos. En particular, la combinación con TailwindCSS ofrece una experiencia de desarrollo altamente personalizable y consistente, aprovechando la potencia de los estilos utilitarios.~\cite{primevue_tailwind}

TailwindCSS se ha consolidado como un framework de utilidades altamente eficiente para el desarrollo de interfaces modernas. Su principal fortaleza radica en el compilador Just-in-Time (JIT), que genera únicamente los estilos utilizados en la aplicación y elimina automáticamente el CSS no empleado. Este enfoque permite resultados de alto rendimiento en producción, como lo demuestra el caso de Netflix Top 10, cuya aplicación completa carga apenas 6.5kB de CSS.~\cite{tailwind_prod}

Además de su eficiencia, TailwindCSS aporta un conjunto de características que favorecen la mantenibilidad y escalabilidad de los proyectos. Entre ellas destacan el sistema de Design Tokens, que garantiza consistencia en colores, tipografías y espaciados; la abstracción de componentes, que permite construir interfaces modulares a partir de estilos utilitarios; y la optimización de la etapa de compilación (build), que asegura entregas más ligeras y rápidas. Estas cualidades lo convierten en una herramienta estratégica para proyectos que requieren interfaces responsivas, personalizables y con un alto nivel de rendimiento.~\cite{scriptbinary_tailwind}

Vite se ha consolidado como una herramienta clave en el ecosistema frontend, destacando por la rapidez que ofrece tanto en la etapa de desarrollo como en la construcción de aplicaciones para producción. Distintos análisis la señalan como un verdadero cambio de paradigma, ya que proporciona arranques casi instantáneos, una retroalimentación rápida durante la programación y un flujo de trabajo que mejora notablemente la experiencia del desarrollador. En producción, genera builds altamente optimizadas y ligeras, mientras que en desarrollo permite mantener un ciclo ágil que se adapta a proyectos de cualquier escala, favoreciendo tanto la eficiencia como el rendimiento general del sistema.~\cite{syncfusion_vite}~\cite{devto_vite_vs_webpack}

Pinia ha reemplazado oficialmente a Vuex como la solución de gestión de estado en Vue 3, consolidándose como una herramienta más moderna y eficiente. Sus mejoras se reflejan en un rendimiento superior, con un 37\% más de rapidez en actualizaciones de estado y un 23\% menos de uso de memoria en aplicaciones complejas. Además, ofrece modularidad nativa sin configuración adicional, lo que simplifica la estructura de proyectos escalables.~\cite{mobilereality_vue_libs}~\cite{devto_pinia}

En entornos de producción, Pinia aporta características clave como la carga diferida (lazy loading) de stores, que reduce el tamaño del bundle inicial; la persistencia del estado mediante localStorage o sessionStorage; y la facilidad para organizar stores modulares que se cargan bajo demanda. Estas cualidades permiten construir aplicaciones más eficientes, escalables y fáciles de mantener, garantizando un control de estado centralizado sin sacrificar el rendimiento.~\cite{metadesign_vue_opt}

La incorporación conjunta de todas estas tecnologías, aporta beneficios significativos para los equipos de desarrollo, potenciando la productividad y la mantenibilidad de proyectos, permitiendo un tiempo reducido de configuración inicial, ofreciendo una experiencia de desarrollo optimizada y promoviendo la reutilización de código, logrando un código base más limpio, organizado y escalable. Además, favorecen una mejor separación de responsabilidades entre capas de la aplicación y simplifican las tareas de pruebas y mantenimiento, consolidando un entorno moderno y eficiente para el desarrollo frontend.

\subsection{Gestión de entorno: UV + Bun}

UV es un gestor de paquetes y proyectos altamente eficiente y veloz, diseñado por Astral para unificar en una sola herramienta las funcionalidades que tradicionalmente dependen de un ecosistema fragmentado en Python~\cite{astral_uv}. Así, reemplaza utilidades como \texttt{pip}, \texttt{pip-tools}, \texttt{virtualenv/venv} y \texttt{pyenv}, ofreciendo una solución integral para todo el ciclo de vida del desarrollo en este lenguaje.~\cite{digitalocean_uv}

Su arquitectura introduce innovaciones significativas que optimizan el rendimiento como por ejemplo, permitiendo descargas paralelas de múltiples paquetes, utilizando caché global optimizado con técnicas como \texttt{Copy-on-Write} y \texttt{hard links} para evitar redundancias, y realiza un manejo inteligente de metadatos, descargando solo la información necesaria, junto a todo esto, sumamos su implementación nativa en Rust, que asegura operaciones compiladas considerablemente más rápidas.~\cite{xebia_uv}~\cite{saaspegasus_uv} Continuando con sus beneficios, en términos de compatibilidad, UV respeta plenamente los estándares oficiales de packaging en Python, empleando \texttt{pyproject.toml} como su fuente para administrar paquetes, junto con archivos de bloqueo universales que garantizan reproducibilidad en múltiples plataformas.~\cite{pydevtools_uv}

Bun es un gestor de paquetes y entorno de ejecución para JavaScript que destaca por su alto rendimiento al utilizar el motor JavaScriptCore de WebKit, en contraste con el motor V8 de Chrome empleado por otros entornos~\cite{strapi_bun_node_perf}. Esta elección tecnológica le otorga ventajas significativas en tiempos de inicio y en operaciones intensivas de CPU. Diversos benchmarks independientes han demostrado que Bun supera consistentemente a Node.js en múltiples métricas: en tareas de cálculo, como la generación y ordenamiento de 100,000 números aleatorios~\cite{dreamhost_bun_node}, Bun reduce los tiempos de ejecución a aproximadamente 1,700 ms frente a los 3,400 ms de Node.js~\cite{dreamhost_bun_node}; en el rendimiento de servidores HTTP alcanza alrededor de 52,000 solicitudes por segundo frente a 13,000 de Node.js~\cite{strapi_bun_node_perf}; y en la instalación de dependencias su gestor de paquetes nativo logra ser hasta 25 veces más rápido que npm, reduciendo de forma drástica los tiempos de configuración de proyectos.~\cite{keepcoding_bun}~\cite{milesweb_bun_npm}

En términos generales, el motivo de uso tanto de Bun en el frontend como de UV en el backend se sustenta en la velocidad, innovación y disrupción tecnológica que ambos están aportando en un corto periodo de existencia. Estas herramientas representan una nueva generación de gestores de entornos y paquetes, capaces de optimizar los flujos de desarrollo sin apartarse de los estándares modernos que guían su evolución, lo que las convierte en una elección estratégica para proyectos que buscan eficiencia y escalabilidad.

\subsection{Git + Github}

Git como sistema de gestor de versiones y Github como plataforma para llevar a cabo dicha tarea en la nube, son dos elementos fundamental que todo informático debe tener, pues en el desarrollo de proyectos de software son herramientas universales para el trabajo bien empleado e incluso colaborativo. Git permite llevar un control preciso de los cambios realizados en el código, facilitando la trazabilidad de cada modificación y la posibilidad de retroceder a versiones anteriores en caso de errores o conflictos. Esto asegura mayor seguridad en el desarrollo y disminuye riesgos de pérdida de información.~\cite{github_guides}

Por su parte, GitHub complementa esta funcionalidad al ofrecer un espacio de almacenamiento remoto y respaldo en la nube, además de un entorno para la colaboración entre equipos de trabajo. Ambos aportan buenas prácticas profesionales, constituyéndose como herramientas indispensables para cualquier programador moderno.

\subsection{Docker Compose}

Docker Compose es una herramienta esencial para la gestión de aplicaciones que requieren múltiples servicios interconectados, pues, a través de un único archivo de configuración en muchas ocasiones simplemente llamado \texttt{docker compose.yml}, es posible definir de manera centralizada los servicios, redes, volúmenes y variables de entorno que conforman la infraestructura de la aplicación. De este modo, se elimina la necesidad de administrar contenedores de forma individual, ofreciendo una visión unificada y ordenada del sistema.~\cite{aidomotics_docker}~\cite{keepcoding_docker}

La principal ventaja de Docker Compose radica en la simplificación de la orquestación de contenedores, automatizando tareas que antes demandaban intervención manual~\cite{hostinger_docker}. Por ejemplo, en entornos donde se emplean arquitecturas de microservicios, facilita la coordinación entre componentes independientes (bases de datos, APIs, servicios web, entre otros), garantizando a la vez el aislamiento necesario para un funcionamiento seguro y eficiente.~\cite{editverse_docker}

Un aspecto clave para la elección de Docker es su capacidad de asegurar la reproducibilidad del entorno. Gracias a su funcionamiento basado en contenedores, es posible ejecutar la misma configuración de manera idéntica en distintos sistemas, evitando discrepancias entre entornos de desarrollo, prueba y producción~\cite{microsoft_microservices_orchestration}. Así, se elimina el problema recurrente de tener que reinstalar manualmente el producto en diferentes dispositivos. Lo que solía generar inconsistencias, errores y pérdida de tiempo, con Docker, estos inconvenientes quedan resueltos, garantizando entornos consistentes, confiables y fáciles de replicar~\cite{tildavps_docker}.